" Install Vim-Plug if it isn't already
if empty(glob('~/.vim/autoload/plug.vim'))
    silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs
        \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
    autocmd VimEnter * PlugInstall --sync | source $MYVIMRC
endif

"   Load Plugins
call plug#begin('~/.vim/plugged')
"Plug 'junegunn/seoul256.vim'
"Plug 'junegunn/goyo.vim'
"Plug 'junegunn/limelight.vim'
"Plug 'liuchengxu/vim-which-key'
"Plug 'tpope/vim-repeat'
Plug 'scrooloose/nerdtree'
Plug 'Xuyuanp/nerdtree-git-plugin'
"Plug 'shougo/unite.vim'
"Plug 'mbbill/undotree'
"Plug 'valloric/youcompleteme'
"Plug 'tpope/vim-surround'
Plug 'bronson/vim-trailing-whitespace'
Plug 'rpdelaney/vim-sourcecfg'
"Plug 'godlygeek/tabular'
Plug 'raimondi/delimitmate'
Plug 'scrooloose/syntastic'
Plug 'itchyny/lightline.vim'
Plug 'tikhomirov/vim-glsl'
"Plug 'craigemery/vim-autotag'
"Plug 'abudden/taghighlight-automirror'

" Colorschemes
Plug 'ErichDonGubler/vim-sublime-monokai'
Plug 'flazz/vim-colorschemes'
Plug 'dracula/vim',{'as':'dracula'}
Plug 'romainl/Apprentice',{'as':'Apprentice'}
call plug#end()

"   Functions(?)

" This is all taken from the vim fandom wiki
" ex command for toggling hex mode - define mapping if desired
command -bar Hexmode call ToggleHex()

" helper function to toggle hex mode
function ToggleHex()
  " hex mode should be considered a read-only operation
  " save values for modified and read-only for restoration later,
  " and clear the read-only flag for now
  let l:modified=&mod
  let l:oldreadonly=&readonly
  let &readonly=0
  let l:oldmodifiable=&modifiable
  let &modifiable=1
  if !exists("b:editHex") || !b:editHex
    " save old options
    let b:oldft=&ft
    let b:oldbin=&bin
    " set new options
    setlocal binary " make sure it overrides any textwidth, etc.
    silent :e " this will reload the file without trickeries
              "(DOS line endings will be shown entirely )
    let &ft="xxd"
    " set status
    let b:editHex=1
    " switch to hex editor
    %!xxd
  else
    " restore old options
    let &ft=b:oldft
    if !b:oldbin
      setlocal nobinary
    endif
    " set status
    let b:editHex=0
    " return to normal editing
    %!xxd -r
  endif
  " restore values for modified and read only state
  let &mod=l:modified
  let &readonly=l:oldreadonly
  let &modifiable=l:oldmodifiable
endfunction

"   Autocmds
augroup fixWhitespace
    autocmd!
    autocmd BufWritePre * if get(g:, 'whitespacefix', 1) | :FixWhitespace
augroup END
autocmd BufWritePre * :retab
autocmd BufWinEnter * normal zR
autocmd FileType c,h,hpp,cpp,diff,cs,python,vim,sh setlocal nowrap

autocmd BufReadPost * if line("'\"") > 0 && line("'\"") <= line("$")
    \| exe "normal! g'\"" | endif

" TODO: Cleanup this whole file, please

"   Leader Key
let mapleader=' '


"   Plugin Config
let delimitMate_matchpairs="(:),[:],{:}"
set tags+=$HOME/.cache/vim/ctags

" Syntastic
set statusline+=%#warningmsg#
set statusline+=%{SyntasticStatuslineFlag()}
set statusline+=%*

let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 1
let g:syntastic_check_on_open = 1
let g:syntastic_check_on_wq = 0

" open NERDTree automatically when vim starts up on opening a directory
autocmd StdinReadPre * let s:std_in=1
autocmd VimEnter * if argc() == 1 && isdirectory(argv()[0]) && !exists("s:std_in") | exe 'NERDTree' argv()[0] | wincmd p | ene | endif

" open NERDTree when no files are specified
autocmd StdinReadPre * let s:std_in=1
autocmd VimEnter * if argc() == 0 && !exists("s:std_in") | NERDTree | endif

" ycm
let g:ycm_seed_identifiers_with_syntax=1
let g:ycm_global_ycm_extra_conf = '$HOME/.vim/plugged/youcompleteme/third_party/ycmd/.ycm_extra_conf.py'
let g:ycm_confirm_extra_conf=0
let g:ycm_collect_identifiers_from_tag_files = 1
set completeopt=longest,menu

"   Some Defaults
syntax enable
set nocompatible
set encoding=UTF-8
set exrc
set secure
"set ruler
set number relativenumber
set hidden
set ttyfast
set laststatus=2
set showmode
set showcmd
set wildmode=longest,list,full

set listchars=tab:\ \ →,eol:¬,space:·
set pastetoggle=<F2>

set statusline=
set statusline+=%#PmenuSel#
set statusline+=%#LineNr#
set statusline+=\ %f
set statusline+=%m\
set statusline+=%=%#CursorColumn#
set statusline+=\ %y
set statusline+=\ %{&fileencoding?&fileencoding:&encoding}
set statusline+=\[%{&fileformat}\]
set statusline+=\ %p%%
set statusline+=\ %l:%c
set statusline+=\ 
"set statusline=%<%F%h%m%r%=%b\ 0x%B\ \ %l,%c%V\ %P

"   Recovery
set backup
set writebackup
set undofile
set swapfile

"   Whitespace
set wrap
"set nowrap
set textwidth=0
set tabstop=4
set shiftwidth=4
"set softtabstop=4
set expandtab
set autoindent
set smartindent

"   Cursor stuff
set scrolloff=3
set matchpairs+=<:> " use % to jump between pairs

"   Searching
set hlsearch
set incsearch
set ignorecase
set smartcase
set showmatch

set foldenable
set foldmethod=syntax
set formatoptions=tcqrn1
let g:sh_fold_enabled=5

"   Bindings
function! GetCursorChar()
    return char2nr(matchstr(getline('.'), '\%' . col('.') . 'c.'))
endfunction

map <leader>l :set list!<CR>
map <leader>/ :let @/=''<CR>
imap <F2> <C-O>:set invpaste paste?<CR>

nnoremap <C-h> <i{<CR>
nnoremap <C-l> >i{<CR>

nnoremap <F2> :set invpaste paste?<CR>
"Spellcheck toggle
nnoremap <silent> <leader>p :setlocal spell!<cr>
"Linewrap toggle
nnoremap <silent> <leader>g :setlocal wrap!<cr>
"Toggle between inserting tabs and spaces
nnoremap <silent> <leader><tab> :setlocal expandtab!<cr>
"Toggle cursorline
nnoremap <silent> <leader><C-c> :setlocal cursorline!<CR>
"Show charcode under cursor
nnoremap <silent> <leader>cc :echo GetCursorChar()<cr>
" Toggle folds
nnoremap <silent> <space>f @=(foldlevel('.')?'za':"\<space>")<CR>
nnoremap <silent> <C-f> zM
nnoremap <leader>F zR
"vnoremap <space><space> zf

"Toggle whitespace fix on file write
nnoremap <F4> :let g:whitespacefix = !get(g:, 'whitespacefix', 1)<CR>

"Reread vimrc
nnoremap <leader>. :source $MYVIMRC<CR>

"Move line up
nnoremap <C-k> VdkP
"Move line down
nnoremap <C-j> Vdp

"Copy line below
nnoremap <C-c> mZVyp`Zj
"Delete line
nnoremap <C-d> mZVd`Z
"Copy in insert mode
inoremap <C-c> <esc>mZVyp`Z<right>i
"Delete in insert mode
inoremap <C-d> <esc>Vdi

"Toggle Hexmode
nnoremap <leader><C-h> :Hexmode<CR>

nnoremap <leader>w :w<CR>
nnoremap <leader>W :w!<CR>
nnoremap <leader>q :q<CR>
nnoremap <leader>Q :q!<CR>
nnoremap <leader>e :e<CR>
nnoremap <leader>E :e!<CR>
nnoremap <leader><C-e> :E<CR>
nnoremap Q :q!<CR>

" Tabs
nnoremap <silent> <leader><C-Right> :tabnext<CR>
nnoremap <silent> <leader><C-Left>  :tabprevious<CR>
nnoremap <silent> <leader><C-w>     :tabclose<CR>

" Splits
nnoremap <silent> <C-L> <C-W>l
nnoremap <silent> <C-H> <C-W>h
nnoremap <silent> <C-K> <C-W>k
nnoremap <silent> <C-J> <C-W>j

nnoremap <leader>T :hi Normal guibg=NONE ctermbg=NONE<cr>

" Plugin binds
nnoremap <leader>pi :PlugInstall<CR>
nnoremap <leader>pc :PlugClean<CR>
nnoremap <leader>pu :PlugUpdate<CR>
nnoremap <leader>pU :PlugUpgrade<CR>
nnoremap <leader>ps :PlugStatus<CR>
map      <leader>t  :NERDTreeToggle<CR>

"   Colors
" For 256 color terminals
set t_Co=256
set t_ut=
set background=dark
let g:lightline = {
            \ 'colorscheme': 'molokai'
            \ }
colorscheme molokai
" Add this to make transparent background
" Add it to the bottom of the colorscheme file
"   and it'll work whenever you use that colorscheme
"hi Normal guibg=NONE ctermbg=NONE

