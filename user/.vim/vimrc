" Install Vim-Plug if it isn't already
if empty(glob('~/.vim/autoload/plug.vim'))
    silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs
        \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
    autocmd VimEnter * PlugInstall --sync | source $MYVIMRC
endif

"   Load Plugins
call plug#begin('~/.vim/plugged')
"Plug 'junegunn/seoul256.vim'
"Plug 'junegunn/goyo.vim'
"Plug 'junegunn/limelight.vim'
"Plug 'liuchengxu/vim-which-key'
"Plug 'tpope/vim-repeat'
Plug 'scrooloose/nerdtree'
Plug 'Xuyuanp/nerdtree-git-plugin'
"Plug 'shougo/unite.vim'
"Plug 'mbbill/undotree'
"Plug 'valloric/youcompleteme'
"Plug 'tpope/vim-surround'
Plug 'bronson/vim-trailing-whitespace'
Plug 'rpdelaney/vim-sourcecfg'
"Plug 'godlygeek/tabular'
Plug 'raimondi/delimitmate'
Plug 'scrooloose/syntastic'
Plug 'itchyny/lightline.vim'
Plug 'tikhomirov/vim-glsl'
"Plug 'craigemery/vim-autotag'
"Plug 'abudden/taghighlight-automirror'
Plug 'withgod/vim-sourcepawn'

" Colorschemes
Plug 'ErichDonGubler/vim-sublime-monokai'
Plug 'flazz/vim-colorschemes'
Plug 'dracula/vim',{'as':'dracula'}
Plug 'romainl/Apprentice',{'as':'Apprentice'}
call plug#end()

"   Functions(?)

" This is all taken from the vim fandom wiki
" ex command for toggling hex mode - define mapping if desired
command -bar Hexmode call ToggleHex()

" helper function to toggle hex mode
function ToggleHex()
  " hex mode should be considered a read-only operation
  " save values for modified and read-only for restoration later,
  " and clear the read-only flag for now
  let l:modified=&mod
  let l:oldreadonly=&readonly
  let &readonly=0
  let l:oldmodifiable=&modifiable
  let &modifiable=1
  if !exists("b:editHex") || !b:editHex
    " save old options
    let b:oldft=&ft
    let b:oldbin=&bin
    " set new options
    setlocal binary " make sure it overrides any textwidth, etc.
    silent :e " this will reload the file without trickeries
              "(DOS line endings will be shown entirely )
    let &ft="xxd"
    " set status
    let b:editHex=1
    " switch to hex editor
    %!xxd
  else
    " restore old options
    let &ft=b:oldft
    if !b:oldbin
      setlocal nobinary
    endif
    " set status
    let b:editHex=0
    " return to normal editing
    %!xxd -r
  endif
  " restore values for modified and read only state
  let &mod=l:modified
  let &readonly=l:oldreadonly
  let &modifiable=l:oldmodifiable
endfunction

"   Autocmds
augroup fixWhitespace
    autocmd!
    autocmd BufWritePre * if get(g:, 'whitespacefix', 1) | :FixWhitespace
augroup END
autocmd BufWritePre * :retab
autocmd BufWinEnter * normal zR
autocmd FileType c,h,hpp,cpp,diff,cs,python,vim,sh setlocal nowrap

autocmd BufRead,BufNewFile *.inc set filetype=include
autocmd BufRead,BufNewFile *.inc set syntax=sourcepawn

autocmd BufReadPost * if line("'\"") > 0 && line("'\"") <= line("$")
    \| exe "normal! g'\"" | endif

" TODO: Cleanup this whole file, please

"   Leader Key
let mapleader=' '


"   Plugin Config
let delimitMate_matchpairs="(:),[:],{:}"
set tags+=$HOME/.cache/vim/ctags


" open NERDTree automatically when vim starts up on opening a directory
autocmd StdinReadPre * let s:std_in=1
autocmd VimEnter * if argc() == 1 && isdirectory(argv()[0]) && !exists("s:std_in") | exe 'NERDTree' argv()[0] | wincmd p | ene | endif

" open NERDTree when no files are specified
"autocmd StdinReadPre * let s:std_in=1
"autocmd VimEnter * if argc() == 0 && !exists("s:std_in") | NERDTree | endif

" ycm
"let g:ycm_seed_identifiers_with_syntax=1
"let g:ycm_global_ycm_extra_conf = '$HOME/.vim/plugged/youcompleteme/third_party/ycmd/.ycm_extra_conf.py'
"let g:ycm_confirm_extra_conf=0
"let g:ycm_collect_identifiers_from_tag_files = 1
"set completeopt=longest,menu

"   Some Defaults
syntax enable
set nocompatible
set encoding=UTF-8
set exrc
set secure
"set ruler
set number relativenumber
set hidden
set ttyfast
set laststatus=2
set showmode
set showcmd
set wildmode=longest,list,full

set listchars=tab:\ \ →,eol:¬,space:·
set pastetoggle=<F2>

set statusline=
set statusline+=%#PmenuSel#
set statusline+=%#LineNr#
set statusline+=\ %f\ A
set statusline+=%m\
set statusline+=%=%#CursorColumn#
set statusline+=\ %y\ AAAA " Filetype
set statusline+=\ %{&fileencoding?&fileencoding:&encoding}
set statusline+=\[%{&fileformat}\]
set statusline+=\ %p%%
set statusline+=\ %L:%c " Current line:Current char
set statusline+=\ 
"set statusline=%<%F%h%m%r%=%b\ 0x%B\ \ %l,%c%V\ %P

" Syntastic
set statusline+=%#warningmsg#
set statusline+=%{SyntasticStatuslineFlag()}
set statusline+=%*

let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 1
let g:syntastic_check_on_open = 1
let g:syntastic_check_on_wq = 0

" Lightline
let g:lightline = { }
let g:lightline.enable = { 'statusline': 1, 'tabline': 1 }
let g:lightline.separator = { 'left': '', 'right': '' }
let g:lightline.subseparator = { 'left': '|', 'right': '|' }
let g:lightline.tabline_separator = g:lightline.separator
let g:lightline.tabline_subseparator = g:lightline.subseparator
let g:lightline.active = {
    \ 'left':  [[ 'mode', 'paste' ],
    \           [ 'readonly', 'filename', 'modified' ]],
    \ 'right': [[ 'lineinfo', 'charinfo' ], [ 'percent' ],
    \           [ 'fileformat', 'fileencoding', 'filetype' ]],
    \ }
let g:lightline.inactive = {
    \ 'left':  [[ 'filename' ]],
    \ 'right': [[ 'lineinfo' ],
    \           [ 'percent' ]],
    \ }
let g:lightline.tabline = {
    \ 'left': [ [ 'tabs' ] ],
    \ 'right': [ [ 'close' ] ] }
let g:lightline.tab = {
    \ 'active': [ 'tabnum', 'filename', 'modified' ],
    \ 'inactive': [ 'tabnum', 'filename', 'modified' ] }

" Statusline/tabline components.
let g:lightline.component = {
    \ 'mode': '%{lightline#mode()}',
    \ 'absolutepath': '%F',
    \ 'relativepath': '%f',
    \ 'filename': '%t',
    \ 'modified': '%M',
    \ 'bufnum': '%n',
    \ 'paste': '%{&paste?"PASTE":""}',
    \ 'readonly': '%R',
    \ 'charvalue': '%b',
    \ 'charvaluehex': '%B',
    \ 'fileencoding': '%{&fenc!=#""?&fenc:&enc}',
    \ 'fileformat': '%{&ff}',
    \ 'filetype': '%{&ft!=#""?&ft:"no ft"}',
    \ 'percent': '%p%%',
    \ 'percentwin': '%P',
    \ 'spell': '%{&spell?&spelllang:""}',
    \ 'lineinfo': '%3l/%-3L',
    \ 'charinfo': '%3v:%03b:%03B',
    \ 'line': '%l',
    \ 'column': '%c',
    \ 'close': '%999X X ',
    \ 'winnr': '%{winnr()}',
    \ }
let g:lightline.component_visible_condition = {
    \ 'modified': '&modified||!&modifiable',
    \ 'readonly': '&readonly',
    \ 'paste': '&paste',
    \ 'spell': '&spell',
    \ }
let g:lightline.component_function = {}
let g:lightline.component_function_visible_condition = {}
let g:lightline.component_expand = {
    \ 'tabs': 'lightline#tabs' }
let g:lightline.component_type = {
    \ 'tabs': 'tabsel',
    \ 'close': 'raw' }
let g:lightline.component_raw = {}
let g:lightline.tab_component = {}
let g:lightline.tab_component_function = {
      \ 'filename': 'lightline#tab#filename',
      \ 'modified': 'lightline#tab#modified',
      \ 'readonly': 'lightline#tab#readonly',
      \ 'tabnum': 'lightline#tab#tabnum' }
let g:lightline.mode_map = {
    \ 'n' : 'NORMAL',
    \ 'i' : 'INSERT',
    \ 'R' : 'REPLACE',
    \ 'v' : 'VISUAL',
    \ 'V' : 'V-LINE',
    \ "\<C-v>": 'V-BLOCK',
    \ 'c' : 'COMMAND',
    \ 's' : 'SELECT',
    \ 'S' : 'S-LINE',
    \ "\<C-s>": 'S-BLOCK',
    \ 't': 'TERMINAL',
    \ }

"   Recovery
set backup
set writebackup
set undofile
set swapfile

"   Whitespace
set wrap
"set nowrap
set textwidth=0
set tabstop=4
set shiftwidth=4
"set softtabstop=4
set expandtab
set autoindent
set smartindent

"   Cursor stuff
set scrolloff=3
set matchpairs+=<:> " use % to jump between pairs

"   Searching
set hlsearch
set incsearch
set ignorecase
set smartcase
set showmatch

set foldenable
set foldmethod=syntax
set formatoptions=tcqrn1
let g:sh_fold_enabled=5

"   Bindings
function! GetCursorChar()
    return char2nr(matchstr(getline('.'), '\%' . col('.') . 'c.'))
endfunction

" Show whitespace characters
map <leader>l :set list!<CR>
map <leader>/ :let @/=''<CR>
imap <F2> <C-O>:set invpaste paste?<CR>

nnoremap <C-h> <i{<CR>
nnoremap <C-l> >i{<CR>

nnoremap <F2> :set invpaste paste?<CR>
"Spellcheck toggle
nnoremap <silent> <leader>p :setlocal spell!<cr>
"Linewrap toggle
nnoremap <silent> <leader>g :setlocal wrap!<cr>
"Toggle between inserting tabs and spaces
nnoremap <silent> <leader><tab> :setlocal expandtab!<cr>
"Toggle cursorline
nnoremap <silent> <leader><C-c> :setlocal cursorline!<CR>
"Show charcode under cursor
nnoremap <silent> <leader>cc :echo GetCursorChar()<cr>
" Toggle folds
nnoremap <silent> <space>f @=(foldlevel('.')?'za':"\<space>")<CR>
nnoremap <silent> <C-f> zM
nnoremap <leader>F zR
"vnoremap <space><space> zf

"Toggle whitespace fix on file write
nnoremap <F4> :let g:whitespacefix = !get(g:, 'whitespacefix', 1)<CR>

"Reread vimrc
nnoremap <leader>. :source $MYVIMRC<CR>

"Move line up
nnoremap <C-k> VdkP
"Move line down
nnoremap <C-j> Vdp

"Copy line below
nnoremap <C-c> mZVyp`Zj
"Delete line
nnoremap <C-d> mZVd`Z
"Copy in insert mode
inoremap <C-c> <esc>mZVyp`Z<right>i
"Delete in insert mode
inoremap <C-d> <esc>Vdi

"Toggle Hexmode
nnoremap <leader>H :Hexmode<CR>

nnoremap <leader>w :w<CR>
nnoremap <leader>W :w!<CR>
nnoremap <leader>q :q<CR>
nnoremap <leader>Q :q!<CR>
nnoremap <leader>e :e<CR>
nnoremap <leader>E :e!<CR>
nnoremap <leader><C-e> :E<CR>
nnoremap Q :q!<CR>

" Tabs
nnoremap <silent> <leader><C-Right> :tabnext<CR>
nnoremap <silent> <leader><C-Left>  :tabprevious<CR>
nnoremap <silent> <leader><C-w>     :tabclose<CR>

" Splits
nnoremap <silent> <leader><C-L> <C-W>l
nnoremap <silent> <leader><C-H> <C-W>h
nnoremap <silent> <leader><C-K> <C-W>k
nnoremap <silent> <leader><C-J> <C-W>j

nnoremap <leader>T :hi Normal guibg=NONE ctermbg=NONE<cr>

" Plugin binds
nnoremap <leader>pi :PlugInstall<CR>
nnoremap <leader>pc :PlugClean<CR>
nnoremap <leader>pu :PlugUpdate<CR>
nnoremap <leader>pU :PlugUpgrade<CR>
nnoremap <leader>ps :PlugStatus<CR>
map      <leader>t  :NERDTreeToggle<CR>

"   Colors
" For 256 color terminals
set t_Co=256
set t_ut=
set background=dark
let g:lightline.colorscheme = 'molokai'
colorscheme molokai
" Add this to make transparent background
" Add it to the bottom of the colorscheme file
"   and it'll work whenever you use that colorscheme
"hi Normal guibg=NONE ctermbg=NONE

